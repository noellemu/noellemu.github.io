<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Noelle Mu | SRE | Open Source</title>
  
  <subtitle>Noelle Mu&#39;s talking here.</subtitle>
  <link href="http://site.noellemu.cloud/atom.xml" rel="self"/>
  
  <link href="http://site.noellemu.cloud/"/>
  <updated>2022-11-26T20:29:07.271Z</updated>
  <id>http://site.noellemu.cloud/</id>
  
  <author>
    <name>Noelle Mu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【HackerRank 1 Week Preparation Kit】01-Plus Minus</title>
    <link href="http://site.noellemu.cloud/c6406c4d2ccc/"/>
    <id>http://site.noellemu.cloud/c6406c4d2ccc/</id>
    <published>2022-11-26T20:14:59.000Z</published>
    <updated>2022-11-26T20:29:07.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现了一个很好玩的英文 OJ：HackerRank，听说在国外蛮火的。这个 OJ 支持 Golang，题目是全英文，自带的编辑器有代码提示和自动补全功能体验非常好（LeetCode 的智能模式至今没支持 Golang。。。），也有一些刷题计划可以选择，正好拿来练练英文阅读能力。</p><p>而且刷了这么久的 LeetCode，真的是被核心代码模式惯坏了，对 ACM 模式一无所知，完全不会读输入输出，是时候找几个 ACM 模式的 OJ 练练手了。</p><h2 id="题目原文"><a href="#题目原文" class="headerlink" title="题目原文"></a>题目原文</h2><p>Given an array of integers, calculate the ratios of its elements that are positive, negative, and zero. Print the decimal value of each fraction on a new line with <code>6</code> places after the decimal.</p><p>Note: This challenge introduces precision problems. The test cases are scaled to six decimal places, though answers with absolute error of up to <code>10^-4</code> are acceptable.</p><p><strong>Example</strong></p><p><code>arr = [1, 1, 0, -1, -1]</code></p><p>There are  elements, two positive, two negative and one zero. Their ratios are <code>2/5 = 0.400000</code>, <code>2/5 = 0.400000</code> and <code>1/5 = 0.200000</code>. Results are printed as:</p><blockquote><p>0.400000<br>0.400000<br>0.200000</p></blockquote><p><strong>Function Description</strong></p><p>Complete the plusMinus function in the editor below.</p><p>plusMinus has the following parameter(s):</p><p>int arr[n]: an array of integers<br>Print<br>Print the ratios of positive, negative and zero values in the array. Each value should be printed on a separate line with 6 digits after the decimal. The function should not return a value.</p><p><strong>Input Format</strong></p><p>The first line contains an integer, <code>n</code>, the size of the array.<br>The second line contains <code>n</code> space-separated integers that describe <code>arr[n]</code>.</p><p><strong>Constraints</strong></p><ul><li><code>0 &lt; n &lt;= 100</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul><p><strong>Output Format</strong></p><p>Print the following <code>3</code> lines, each to <code>6</code> decimals:</p><ol><li>proportion of positive values</li><li>proportion of negative values</li><li>proportion of zeros</li></ol><p><strong>Sample Input</strong></p><blockquote><p>STDIN           Function</p><hr><p>6               arr[] size n &#x3D; 6<br>-4 3 -9 0 4 1   arr &#x3D; [-4, 3, -9, 0, 4, 1]</p></blockquote><p><strong>Sample Output</strong></p><blockquote><p>0.500000<br>0.333333<br>0.166667</p></blockquote><p><strong>Explanation</strong></p><p>There are <code>3</code> positive numbers, <code>2</code> negative numbers, and <code>1</code> zero in the array.<br>The proportions of occurrence are positive: <code>3/6 = 0.500000</code>, negative: <code>2/6 = 0.333333</code> and zeros: <code>1/6 = 0.166667</code>.</p><h2 id="难度"><a href="#难度" class="headerlink" title="难度"></a>难度</h2><p>Easy</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>入门题，题目的大概含义就是求出 <code>arr</code> 中正数、负数和零在数组中的比重，分别统计然后除以数组长度并按要求打印出来即可，注意类型转换。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，需要遍历数组一次。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">plusMinus</span><span class="params">(arr []<span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Write your code here</span></span><br><span class="line">    n := <span class="type">float64</span>(<span class="built_in">len</span>(arr))</span><br><span class="line">    negatives, positives, zeros := <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span> &#123;</span><br><span class="line">            negatives++</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">            positives++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zeros++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%.6f\n%.6f\n%.6f\n&quot;</span>, positives / n, negatives / n, zeros / n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;发现了一个很好玩的英文 OJ：HackerRank，听说在国外蛮火的。这个 OJ 支持 Golang，题目是全英文，自带的编辑器有代码提示和</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="HackerRank" scheme="http://site.noellemu.cloud/categories/Algorithm/HackerRank/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Simulation" scheme="http://site.noellemu.cloud/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】31. Next Permutation</title>
    <link href="http://site.noellemu.cloud/52db1f9bee4e/"/>
    <id>http://site.noellemu.cloud/52db1f9bee4e/</id>
    <published>2022-11-25T19:59:26.000Z</published>
    <updated>2022-11-26T20:12:47.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/next-permutation/">31. Next Permutation</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>这道题是一个既有的算法，维基百科地址：<a href="https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order">Permutation - Wikipedia</a>，原文如下：</p><blockquote><p>The following algorithm generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.</p><ol><li>Find the largest index k such that <code>a[k] &lt; a[k + 1]</code>. If no such index exists, the permutation is the last permutation.</li><li>Find the largest index l greater than k such that <code>a[k]</code> &lt; <code>a[l]</code>.</li><li>Swap the value of <code>a[k]</code> with that of <code>a[l]</code>.</li><li>Reverse the sequence from <code>a[k + 1]</code> up to and including the final element <code>a[n]</code>.</li></ol></blockquote><p>翻译过来就是：</p><blockquote><p>以下算法给出了生成某个全排列的字典序中的下一个全排列的方法，该算法是原地工作的。</p><ol><li>找到最大的满足 <code>a[k] &lt; a[k + 1]</code> 的下标 <code>k</code>（也就是最后一个升序序列的起点），如果找不到，则该全排列就是最后一个全排列（即整个数组为一个降序序列。按题目要求，我们要翻转整个数组）。</li><li>找到最大的满足 <code>a[k] &lt; a[l]</code> 的下标 <code>l</code>（也就是从下标 <code>k</code> 开始比 <code>a[k]</code> 大的第一个数）。</li><li>交换 <code>a[k]</code> 和 <code>a[l]</code> 的值。</li><li>将数组从 <code>a[k + 1]</code> 开始到数组末尾的部分翻转（此时这部分是一个升序序列）。</li></ol></blockquote><p>按照这个算法实现即可。这里我用 <code>i</code> 和 <code>j</code> 代表算法描述中的 <code>k</code> 和 <code>k + 1</code>，用 <code>k</code> 代表 <code>l</code>，并且从后往前遍历数组。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，需要遍历数组三次，前两次找到 <code>i</code> 和 <code>j</code>，第三次翻转 <code>nums[j:]</code>。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextPermutation</span><span class="params">(nums []<span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最后一个升序对 (i, j)</span></span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    i, j := n - <span class="number">2</span>, n - <span class="number">1</span></span><br><span class="line">    k := n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[j] &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i--</span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 i &lt; 0，说明整个数组都是降序的，跳过后续步骤直接翻转整个数组</span></span><br><span class="line">    <span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 找到第一个比 i 大的值 k</span></span><br><span class="line">        <span class="keyword">for</span> nums[i] &gt;= nums[k] &#123;</span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换 nums[i] 和 nums[k]</span></span><br><span class="line">        nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转 nums[j:]</span></span><br><span class="line">    <span class="keyword">for</span> a, b := j, n<span class="number">-1</span>; a &lt; b; a, b = a+<span class="number">1</span>, b<span class="number">-1</span> &#123;</span><br><span class="line">        nums[a], nums[b] = nums[b], nums[a]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/next-permutation/&quot;&gt;31. N</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Simulation" scheme="http://site.noellemu.cloud/tags/Simulation/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】39. Combination Sum</title>
    <link href="http://site.noellemu.cloud/3ab051503b70/"/>
    <id>http://site.noellemu.cloud/3ab051503b70/</id>
    <published>2022-11-25T19:45:24.000Z</published>
    <updated>2022-11-26T19:59:23.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/combination-sum/">39. Combination Sum</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>全排列问题，一眼递归回溯。</p><p>这个问题的求解过程有点类似于 <a href="https://leetcode.cn/problems/permutations/solution/">46</a>，都需要使用类似于枚举输入数组 <code>candidates</code> 全排列的思路，不过这道题的 <code>candidates</code> 数组中的元素是可以重复使用的，因此每次递归时都需要从当前结点开始。此外，为避免重复解，在每次递归遍历 <code>candidates</code> 数组时需要从当前搜索位置 <code>start</code> 开始遍历（当然你也可以考虑使用 <code>visited</code> 标记数组之类的方法来去重），每次从 <code>target</code> 中减掉当前遍历到的元素，直到 <code>target</code> 等于 0 时达到递归边界，此时根结点到该叶子结点的路径即为一组解。</p><p>由于输入规模在递归回溯类问题中比较大，所以可以考虑对解空间树剪枝。先对 <code>candidates</code> 从小到大排序，当遍历到解空间树的某个结点时，如果 <code>target</code> 减掉要遍历的下一个元素的值为负数，说明这个值和之后所有的值都不能满足要求，直接 <code>break</code> 即可。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(S)，其中 S 为所有可行解的长度之和。</p><p>空间复杂度：O(target)，最坏情况即 <code>candidates</code> 为 <code>[1]</code> 时，递归调用栈的最大深度为 <code>target</code>。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">combinationSum</span><span class="params">(candidates []<span class="type">int</span>, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    sort.Ints(candidates)</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start, target <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 递归边界：target 为 0，表示找到了一组解</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> &#123;</span><br><span class="line">            _path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(_path, path)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, _path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 依次遍历剩余的数字，避免结果重复</span></span><br><span class="line">        <span class="keyword">for</span> i := start; i &lt; <span class="built_in">len</span>(candidates); i++ &#123;</span><br><span class="line">            <span class="comment">// 由于前面已经对 candidates 排过序了，所以如果 target - candidates[i] 是负数，可以直接跳过后面的数</span></span><br><span class="line">            <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            path = <span class="built_in">append</span>(path, candidates[i])</span><br><span class="line">            <span class="comment">// 由于数字可以重复使用，所以这里的搜索起点仍然是当前位置</span></span><br><span class="line">            dfs(i, target - candidates[i])</span><br><span class="line">            path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, target)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/combination-sum/&quot;&gt;39. Co</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Recursion" scheme="http://site.noellemu.cloud/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】22. Generate Parentheses</title>
    <link href="http://site.noellemu.cloud/d5fec3603d29/"/>
    <id>http://site.noellemu.cloud/d5fec3603d29/</id>
    <published>2022-11-25T18:52:44.000Z</published>
    <updated>2022-11-26T19:46:29.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/generate-parentheses/">22. Generate Parentheses</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>全排列问题，且 n 最大只有 8，一眼递归回溯（本题不需要回溯）。</p><p>这道题可以从左右括号的个数的角度出发去思考。规定解空间树从根结点到叶子结点的路径为所求的括号序列，根结点为空字符串，每一个结点都由上一个结点放置一个左括号或右括号而来。由于一个合法的括号序列中左括号的个数总是等于右括号的个数，即左右括号都一共有 n 个，并且总是以左括号开始，且该问题只包含小括号无需考虑不同类型的括号匹配是否合法，所以我们可以规定在递归回溯中优先放置左括号，且解空间树当且仅当从根结点到当前结点的路径上的左括号的个数大于等于右括号的个数时，才允许解空间树产生新的结点，即剩余可用的左括号数不能比右括号数多。</p><p>将以上思路代入递归回溯算法的模板中即可。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O((4^n)&#x2F;√n)，这个问题的时间复杂度分析超出了我的能力范围，详细的分析过程可以去看官方题解。</p><p>空间复杂度：O(n)，递归调用栈的最大深度为 2n。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ans []<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">string</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(left, right <span class="type">int</span>, s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 只允许左括号的个数大于等于右括号的个数，即剩余的左括号个数不能比剩余的右括号个数多</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; right &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号和右括号的个数都用完了，说明找到了一组解</span></span><br><span class="line">        <span class="comment">// 这里由于 Go 语言中字符串是值类型，并且每次传入的 s 都是新的字符串，所以不需要拷贝</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左括号的个数大于 0，则尝试放置左括号</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span> &#123;</span><br><span class="line">            dfs(left<span class="number">-1</span>, right, s + <span class="string">&quot;(&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span> &#123;</span><br><span class="line">            dfs(left, right<span class="number">-1</span>, s + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(n, n, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/generate-parentheses/&quot;&gt;2</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Recursion" scheme="http://site.noellemu.cloud/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】46. Permutations</title>
    <link href="http://site.noellemu.cloud/e2f9ec0104dd/"/>
    <id>http://site.noellemu.cloud/e2f9ec0104dd/</id>
    <published>2022-11-25T18:27:42.000Z</published>
    <updated>2022-11-26T18:51:20.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/permutations/solution/">46. Permutations</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>全排列问题，并且输入的最大长度只有 6，一眼递归回溯，这道题算是递归回溯的入门题了（不过我个人认为不需要回溯的更适合新手练习，比如 <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17</a> 和 <a href="https://leetcode.cn/problems/generate-parentheses/submissions/">22</a>）。</p><p>先考虑递归的条件：</p><ul><li><code>nums</code> 长度为 1，全排列就是 <code>nums[0]</code> 自身。</li><li><code>nums</code> 长度为 2，全排列为 <code>[[nums[0], nums[1]], [nums[1], nums[0]]]</code>。</li><li><code>nums</code> 长度为 n，全排列就是 <code>nums[n]</code> 和 <code>nums[0:n-1]</code> 的全排列。</li></ul><p>本题有一个隐含条件：数字不能重复使用，那么如何去重就成为了一个问题。一般在去重类的问题中，除了算法本身可以去重（例如官方题解那种不使用辅助数组的方法）之外，我们可以使用标记数组 <code>visited</code> 进行去重。</p><p>递归回溯类的问题一般都可以画出一棵树（解空间树），我们用 <code>path</code> 保存解空间树从根结点到叶子结点之间的路径。上述递归条件如果画成一棵 n 叉树会更加容易想到，所求的全排列就是根结点到叶子结点中经过的结点值不相同的路径的集合，综合这些条件代入递归回溯算法的模板即可。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n * n!)，其中 n 为 <code>nums</code> 的长度。</p><p>空间复杂度：O(n)，递归调用栈的最大深度为 n。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ans [][]<span class="type">int</span></span><br><span class="line">    visited := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>, []<span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(start <span class="type">int</span>, path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> start == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">            <span class="comment">// 这里必须 copy，否则会 WA</span></span><br><span class="line">            _path := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">            <span class="built_in">copy</span>(_path, path)</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, _path)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i, v := <span class="keyword">range</span> nums &#123;</span><br><span class="line">            <span class="comment">// 只能用 nums 数组中没使用过的数</span></span><br><span class="line">            <span class="keyword">if</span> !visited[i] &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span></span><br><span class="line">                path = <span class="built_in">append</span>(path, v)</span><br><span class="line">                dfs(start + <span class="number">1</span>, path)</span><br><span class="line">                path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">                visited[i] = <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">0</span>, []<span class="type">int</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/permutations/solution/&quot;&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Recursion" scheme="http://site.noellemu.cloud/tags/Recursion/"/>
    
    <category term="Backtrack" scheme="http://site.noellemu.cloud/tags/Backtrack/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】17. Letter Combinations of a Phone Number</title>
    <link href="http://site.noellemu.cloud/d35d64ad76b6/"/>
    <id>http://site.noellemu.cloud/d35d64ad76b6/</id>
    <published>2022-11-25T18:16:16.000Z</published>
    <updated>2022-11-26T18:49:52.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. Letter Combinations of a Phone Number</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>全排列（Combination &#x2F; Permutation）问题，并且问题规模不大（<code>digits</code> 的最大长度为 6），一眼递归回溯（本题不需要回溯）。</p><p>递归问题首先从边界条件开始考虑，然后思考能不能转换为更小的问题：</p><ul><li>0 个数字，不需要任何操作，直接返回（相当于得到一个空字符串）。</li><li>1 个数字，枚举这个数字所对应的所有字母，相当于这个数字对应的所有字母拼接空字符串。</li><li>2 个数字，枚举第二个数字对应的所有字母，并与第一个数字对应的所有字母拼接。</li><li>n 个数字，枚举第 n 个数字对应的所有字母，并与第 n - 1 个数字对应的所有结果拼接。</li></ul><p>按照以上方法编写递归代码即可。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(3^m * 4^n)，其中 m 为输入中对应 3 个字母的数字总数，n 为输入中对应 4 个字母的数字总数。</p><p>空间复杂度：O(m + n)，其中 m 为输入中对应 3 个字母的数字总数，n 为输入中对应 4 个字母的数字总数，m + n 为递归调用栈的最大深度。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    numberMap = <span class="keyword">map</span>[<span class="type">byte</span>][]<span class="type">string</span>&#123;</span><br><span class="line">        <span class="string">&#x27;2&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;3&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;4&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;g&quot;</span>, <span class="string">&quot;h&quot;</span>, <span class="string">&quot;i&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;5&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;j&quot;</span>, <span class="string">&quot;k&quot;</span>, <span class="string">&quot;l&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;6&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;m&quot;</span>, <span class="string">&quot;n&quot;</span>, <span class="string">&quot;o&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;7&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;p&quot;</span>, <span class="string">&quot;q&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="string">&quot;s&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;8&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;t&quot;</span>, <span class="string">&quot;u&quot;</span>, <span class="string">&quot;v&quot;</span>&#125;,</span><br><span class="line">        <span class="string">&#x27;9&#x27;</span>: []<span class="type">string</span>&#123;<span class="string">&quot;w&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;z&quot;</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">letterCombinations</span><span class="params">(digits <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">// 因为有 0 个字符时需要返回 [] 而不是 [&quot;&quot;]，所以要特殊判断一下</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(digits) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ans []<span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, <span class="type">int</span>)</span></span></span><br><span class="line">    dfs = <span class="function"><span class="keyword">func</span><span class="params">(combination <span class="type">string</span>, nextIndex <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 遍历到字符串末尾，说明找到了一组解</span></span><br><span class="line">        <span class="keyword">if</span> nextIndex == <span class="built_in">len</span>(digits) &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则对当前遍历到的字符集合中的每一个字符都尝试执行递归操作</span></span><br><span class="line">        <span class="keyword">for</span> _, s := <span class="keyword">range</span> numberMap[digits[nextIndex]] &#123;</span><br><span class="line">            dfs(combination + s, nextIndex + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/letter-combinations-of-a</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Recursion" scheme="http://site.noellemu.cloud/tags/Recursion/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】15. 3Sum</title>
    <link href="http://site.noellemu.cloud/9623d83cd926/"/>
    <id>http://site.noellemu.cloud/9623d83cd926/</id>
    <published>2022-11-25T18:02:40.000Z</published>
    <updated>2022-11-26T18:16:42.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/3sum/">15. 3Sum</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>最简单的暴力方法（时间复杂度为 O(n ^ 3)）相信大家都能想到，但这个问题的难点在于去除重复解，在暴力方法中，可以使用哈希表来去除。</p><p>这道题目的最优解是排序 + 双指针。我们可以先对 <code>nums</code> 数组从小到大排序，然后依次遍历每一个负数并跳过重复的数，然后定义 <code>l</code>、<code>r</code> 两个指针分别指向遍历到的数之后的第一个数和数组的末尾，并计算遍历到的数、<code>nums[l]</code>、<code>nums[r]</code> 相加是 0、正数还是负数。如果是 0，则找到了一组解；如果是负数，说明 <code>nums[l]</code> 太小，将 <code>l</code> 向右（更大的数的方向）移动；如果是正数，说明 <code>nums[r]</code> 太大，将 <code>r</code> 向左（更小的数的方向）移动，直到两个指针相遇，注意在移动过程中需要跳过重复的数。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n ^ 2)，其中排序算法 O(nlog n)，双指针遍历过程 O(n) * O(n) &#x3D; O(n ^ 2)：对于数组中的每一个数，在最坏情况下双指针都要遍历完整个数组。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    ans := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="comment">// 如果第一个元素就大于 0，说明后面不可能存在小于 0 的解了，停止搜索</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 跳过重复的数</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        l, r := i + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] + nums[i] == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 等于 0，找到了一组解</span></span><br><span class="line">                ans = <span class="built_in">append</span>(ans, []<span class="type">int</span>&#123;nums[i], nums[l], nums[r]&#125;)</span><br><span class="line">                <span class="comment">// 跳过重复的数</span></span><br><span class="line">                <span class="keyword">for</span> l &lt; r &amp;&amp; nums[l] == nums[l+<span class="number">1</span>] &#123;</span><br><span class="line">                    l++</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> l &lt; r &amp;&amp; nums[r] == nums[r<span class="number">-1</span>] &#123;</span><br><span class="line">                    r--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果结果大于 0，尝试移动右指针，否则移动左指针</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] + nums[r] + nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                r--</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/3sum/&quot;&gt;15. 3Sum&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Two Pointers" scheme="http://site.noellemu.cloud/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】34. Find First and Last Position of Element in Sorted Array</title>
    <link href="http://site.noellemu.cloud/816153baed83/"/>
    <id>http://site.noellemu.cloud/816153baed83/</id>
    <published>2022-11-25T17:54:07.000Z</published>
    <updated>2022-11-26T18:16:52.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>看到 O(log n) 的时间复杂度限制第一反应二分查找。</p><p>最简单的暴力方法（时间复杂度 O(n)）相信大家都会，但是两次二分查找这一方法也不难想到——第一次查找 <code>target</code> 第一次出现的位置，第二次查找 <code>target + 1</code> 第一次出现的位置，它的前一个位置就是 <code>target</code> 最后出现的位置。</p><p>在查找 <code>target</code> 第一次出现的位置时，查找完毕后需要特殊判断（二分查找左边界 <code>l</code> 是否越界，或者 <code>nums[l]</code> 是否为 <code>target</code>），如果不符合上述判断条件则认为 <code>target</code> 在数组中不存在。查找最后出现的位置时则不需要，因为此时 <code>target</code> 肯定在数组中，而 <code>target + 1</code> 可能本来就不在数组中，或者查找到的位置是数组末尾，这两种情况下查找得到的右边界都是正确的。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(log n)，为二分查找算法的时间复杂度。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchRange</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    left, right := <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 查找左边界</span></span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        m := l + ((r-l)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target &#123;</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// m &gt;= target</span></span><br><span class="line">            r = m - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l &gt; <span class="built_in">len</span>(nums)<span class="number">-1</span> || nums[l] != target &#123;</span><br><span class="line">        <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left = l</span><br><span class="line">    <span class="comment">// 查找右边界</span></span><br><span class="line">    l, r = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        m := l + ((r-l)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> nums[m] &lt; target + <span class="number">1</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// m &gt;= target + 1</span></span><br><span class="line">            r = m - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    right = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;left, right&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/find-first-and-last-posi</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Binary Search" scheme="http://site.noellemu.cloud/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】33. Search in Rotated Sorted Array</title>
    <link href="http://site.noellemu.cloud/03b20af16870/"/>
    <id>http://site.noellemu.cloud/03b20af16870/</id>
    <published>2022-11-25T17:39:04.000Z</published>
    <updated>2022-11-26T18:16:48.004Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. Search in Rotated Sorted Array</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>看到 O(log n) 的时间复杂度第一反应二分查找。</p><p>这道题需要分情况讨论，一图胜千言：</p><p><img src="https://pic.leetcode.cn/1669485127-hCyVUY-IMG_33F9763FE2FE-1.jpeg" alt="Binary Search"></p><p>解释（设 <code>m</code> 为本次二分查找的中心点）：</p><ul><li>当数组的左半部分不包含旋转部分时，<code>target</code> 在左半部分的条件为：<code>nums[0] &lt;= target &lt; nums[m]</code>。</li><li>当数组的左半部分包含旋转部分时，有两种情况：<ul><li><ol><li><code>target</code> 不在旋转部分，此时条件为：<code>nums[m] &lt; nums[0] &lt;= target</code>。</li></ol></li><li><ol start="2"><li><code>target</code> 在旋转部分，此时条件为：<code>nums[m] &lt;= target &lt; nums[0]</code>。</li></ol></li></ul></li></ul><p>对于以上三种情况，都可以认为 <code>target</code> 在数组的左半部分，否则在数组的右半部分，按照这个条件代入到二分查找的代码中即可。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(log n)，为二分查找算法的时间复杂度。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><p>其实查询条件可以优化，现在这样写有点长，而且如果代码高亮没有括号着色功能的话容易看懵。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    l, r := <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">        m := l + ((r-l)&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> nums[m] == target &#123;</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>]&lt;nums[m] &amp;&amp; nums[<span class="number">0</span>]&lt;=target &amp;&amp; target&lt;nums[m]) || (nums[<span class="number">0</span>]&gt;nums[m] &amp;&amp; (nums[m]&lt;nums[<span class="number">0</span>] &amp;&amp; nums[<span class="number">0</span>]&lt;=target) || (target&lt;=nums[m] &amp;&amp; nums[m]&lt;nums[<span class="number">0</span>])) &#123;</span><br><span class="line">            r = m - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/search-in-rotated-sorted</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Binary Search" scheme="http://site.noellemu.cloud/tags/Binary-Search/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】48. Rotate Image</title>
    <link href="http://site.noellemu.cloud/c96db4f9094a/"/>
    <id>http://site.noellemu.cloud/c96db4f9094a/</id>
    <published>2022-11-25T17:30:54.000Z</published>
    <updated>2022-11-26T17:38:03.564Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/rotate-image/">48. Rotate Image</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>这道题与其说是一道算法题，不如说是一道脑筋急转弯（严格意义上说，应该是道数学题，详见官方题解）。</p><p>在空间复杂度为 O(1) 的限制条件下，比较容易想到的方法是从内向外依次旋转四条边，但是这个方法实现起来比较复杂，也比较容易出错。</p><p>其实顺时针旋转 90˚ 最简单的方法是先沿主对角线翻转（也就是旋转 270˚），然后再水平翻转。同理，旋转其他 90˚ 倍数的情况也可以转换为先沿对角线翻转，再水平或垂直翻转的情况。</p><h2 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h2><p>时间复杂度：O(n ^ 2)，需要两次遍历，每次都会遍历矩阵中一半的元素。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rotate</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 沿对角线旋转 270 度</span></span><br><span class="line">    n := <span class="built_in">len</span>(matrix)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再水平翻转一次</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++ &#123;</span><br><span class="line">            matrix[i][n-j<span class="number">-1</span>], matrix[i][j] = matrix[i][j], matrix[i][n-j<span class="number">-1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/rotate-image/&quot;&gt;48. Rotat</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Brain Tester" scheme="http://site.noellemu.cloud/tags/Brain-Tester/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】19. Remove Nth Node From End of List</title>
    <link href="http://site.noellemu.cloud/554b45c19de4/"/>
    <id>http://site.noellemu.cloud/554b45c19de4/</id>
    <published>2022-11-25T14:34:53.000Z</published>
    <updated>2022-11-25T14:50:04.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>看到链表第一反应：双指针。</p><p>求链表长度等比较简单的方法就不讲了，这里讲一下最优解（双指针）。</p><p>这道题如果是一个有头结点的链表，那么能简化很多代码，我们可以给链表手动添加一个头结点 <code>dummy</code>。初始情况下快指针 <code>f</code> 指向第一个结点 <code>head</code>，慢指针 <code>s</code> 指向头结点 <code>dummy</code>。由于需要求倒数第 n 个结点，那么可以让快指针 <code>f</code> 先走 n 步，然后快慢指针一起走，直到 <code>f</code> 越界为止，此时 <code>s</code> 指向的就是倒数第 <code>n</code> 个结点的前一个结点，直接把 <code>s</code> 的下一个结点从链表中摘除（<code>s.Next = s.Next.Next</code>）即可。注意最后需要返回 <code>dummy.Next</code>，否则链表中只有一个结点的情况会 WA（也可以使用 <code>head.Next == nil</code> 特殊判断一下）。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，需要完整遍历一次链表。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    dummy := &amp;ListNode&#123;Val: <span class="number">-1</span>, Next: head&#125;</span><br><span class="line">    f, s := head, dummy</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        f = f.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> f != <span class="literal">nil</span> &#123;</span><br><span class="line">        f = f.Next</span><br><span class="line">        s = s.Next</span><br><span class="line">    &#125;</span><br><span class="line">    s.Next = s.Next.Next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/remove-nth-node-from-end</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Two Pointers" scheme="http://site.noellemu.cloud/tags/Two-Pointers/"/>
    
    <category term="Linked List" scheme="http://site.noellemu.cloud/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】11. Container With Most Water</title>
    <link href="http://site.noellemu.cloud/4b76ec1a08c6/"/>
    <id>http://site.noellemu.cloud/4b76ec1a08c6/</id>
    <published>2022-11-25T13:45:39.000Z</published>
    <updated>2022-11-25T14:48:18.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/container-with-most-water/">11. Container With Most Water</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>不难想到我们每次都需要向内移动两侧的板来计算可能达到的最大容量，并且在这个移动过程中维护最大容量，那么如何移动就成了一个问题。如果想让容量尽可能的大，那么我们就需要每次都移动两侧较短的板（如果长度相同的话则移动哪个都可以），直到容器的宽度为 0，这样问题就转换为了一个很简单的双指针问题。</p><p>个人认为其实这道题与其说是考察什么算法，不如说是一道博弈论的题目。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，需要遍历数组一次。</p><p>空间复杂度：O(1)，只使用了常数个数的存储空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxArea</span><span class="params">(height []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    maxAmount := <span class="number">0</span></span><br><span class="line">    l, r := <span class="number">0</span>, <span class="built_in">len</span>(height)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">        <span class="comment">// 求出两侧较短的板的高度</span></span><br><span class="line">        h := height[l]</span><br><span class="line">        <span class="keyword">if</span> height[l] &gt; height[r] &#123;</span><br><span class="line">            h = height[r]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 求出此时容器的容量，并维护最大容量</span></span><br><span class="line">        amount := (r - l) * h</span><br><span class="line">        <span class="keyword">if</span> amount &gt; maxAmount &#123;</span><br><span class="line">            maxAmount = amount</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 移动较短的一侧</span></span><br><span class="line">        <span class="keyword">if</span> height[l] &lt; height[r] &#123;</span><br><span class="line">            l++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxAmount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/container-with-most-wate</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Two Pointers" scheme="http://site.noellemu.cloud/tags/Two-Pointers/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】5. Longest Palindromic Substring</title>
    <link href="http://site.noellemu.cloud/015299e0586e/"/>
    <id>http://site.noellemu.cloud/015299e0586e/</id>
    <published>2022-11-25T13:25:03.000Z</published>
    <updated>2022-11-25T14:49:00.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>这道题其实也是一道动态规划的题目，并且使用的是一种比较特殊的方法：中心扩展算法。</p><p>一个字符串是回文串的条件如下：</p><ol><li>串长为 1 时，该字符串是回文串。</li><li>串长为 2 时，如果该字符串的两个字符相同，则该字符串是回文串。</li><li>串长大于等于 3 时，如果该字符串去掉头尾两个字符仍然是回文串，那么该字符串是回文串。</li></ol><p>据此可以推导出状态转换方程：</p><ul><li><code>dp[i][i] = true</code></li><li><code>dp[i][i+1] = (s[i] == s[i+1])</code></li><li><code>dp[i][j] = dp[i+1][j-1] &amp;&amp; s[i] == s[j]</code></li></ul><p>根据状态转换方程可以得到表达式 <code>if s[i] == s[j] &amp;&amp; (j-i&lt;=2 || dp[i+1][j-1]) &#123; /* s[i][j] 是回文串 */ &#125;</code>，因为无论有几个字符，回文串的第一个字符和最后一个字符一定都是相同的（也就是 <code>s[l] == s[r]</code>），可以提出来当作公共条件。根据这个表达式依次计算并维护最长回文串的长度和边界即可。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n^2)，需要遍历数组 n ^ 2 次。</p><p>空间复杂度：O(n^2)，需要一个 n * n 的 DP 数组辅助计算。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestPalindrome</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    &#125;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    maxL, maxR := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    maxLen := <span class="number">0</span></span><br><span class="line">    <span class="comment">// 构造一个 n * n 的数组暂存结果</span></span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">bool</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始状态：l = r 时，dp[l][r] = true</span></span><br><span class="line">    <span class="comment">// 状态转移方程：当 s[l] = s[r] 且 l - r &lt; 2（子串只有两个以下字符）或 dp[l+1][r-1] = true 时，dp[l][r] = true</span></span><br><span class="line">    <span class="keyword">for</span> r := <span class="number">1</span>; r &lt; <span class="built_in">len</span>(s); r++ &#123;</span><br><span class="line">        <span class="keyword">for</span> l := <span class="number">0</span>; l &lt; r; l++ &#123;</span><br><span class="line">            <span class="keyword">if</span> s[l] == s[r] &amp;&amp; (r-l&lt;=<span class="number">2</span> || dp[l+<span class="number">1</span>][r<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[l][r] = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">if</span> r - l + <span class="number">1</span> &gt; maxLen &#123;</span><br><span class="line">                    maxLen = r - l + <span class="number">1</span></span><br><span class="line">                    maxL, maxR = l, r</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意 Golang 的截取操作为左闭右开</span></span><br><span class="line">    <span class="keyword">return</span> s[maxL:maxR+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-palindromic-subs</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Dynamic Programming (DP)" scheme="http://site.noellemu.cloud/tags/Dynamic-Programming-DP/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】3. Longest Substring Without Repeating Characters</title>
    <link href="http://site.noellemu.cloud/50d286f3428f/"/>
    <id>http://site.noellemu.cloud/50d286f3428f/</id>
    <published>2022-11-25T12:50:22.000Z</published>
    <updated>2022-11-25T14:49:39.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>这道题可以说是滑窗的入门题了。</p><p>用 <code>l</code> 和 <code>r</code> 两个变量规定滑窗的左右两端，<code>l</code> 每次循环前进一个字符，并把离开滑窗的字符 <code>s[l-1]</code> 从滑窗中移除。<code>l</code> 前进完毕后，开始尝试扩张滑窗：<code>r</code> 每次前进一个字符，并把进入滑窗的字符 <code>s[r]</code> 添加到哈希表中，直到 <code>r</code> 越界或 <code>s[r]</code> 在哈希表中出现时，停止扩张，计算滑窗长度 <code>r - l</code> 并更新滑窗的最大长度 <code>ans</code>，最后返回 <code>ans</code> 即可。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，需要将 <code>s</code> 遍历一次。</p><p>空间复杂度：O(|∑|)，题目规定“s consists of English letters, digits, symbols and spaces”，即 ASCII 字符集，因此可以认为最坏情况为 ASCII 字符集中的所有字符都出现在滑窗中，所以 ∑ 为 ASCII 字符集的长度，即 <code>128</code>。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">bool</span>)</span><br><span class="line">    ans, r := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">0</span>; l &lt; <span class="built_in">len</span>(s); l++ &#123;</span><br><span class="line">        <span class="comment">// 从哈希表里删除离开滑窗的字符</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">delete</span>(m, s[l<span class="number">-1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始尝试向右扩张滑窗，直到越界或遇到滑窗中已有的字符</span></span><br><span class="line">        <span class="comment">// 每次将一个字符纳入滑窗，都将它放入哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> ; r &lt; <span class="built_in">len</span>(s) &amp;&amp; !m[s[r]]; r++ &#123;</span><br><span class="line">            m[s[r]] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向右扩张完毕，计算出滑窗当前的长度 r - l，并与最大值比较</span></span><br><span class="line">        <span class="keyword">if</span> r - l &gt; ans &#123;</span><br><span class="line">            ans = r - l</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/longest-substring-withou</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Hash Map" scheme="http://site.noellemu.cloud/tags/Hash-Map/"/>
    
    <category term="Sliding Window Algorithm" scheme="http://site.noellemu.cloud/tags/Sliding-Window-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】2. Add Two Numbers</title>
    <link href="http://site.noellemu.cloud/f37957f67304/"/>
    <id>http://site.noellemu.cloud/f37957f67304/</id>
    <published>2022-11-25T12:14:28.000Z</published>
    <updated>2022-11-25T14:50:29.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/add-two-numbers/">2. Add Two Numbers</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>这道题比较简单，使用一个变量 <code>carry</code> 记录进位信息，然后边遍历边相加边判断进位即可，结果可以写入一个新的链表 <code>ans</code>。</p><p>设 <code>l1</code> 当前遍历到的结点为 <code>p1</code>，<code>l2</code> 当前遍历到的结点为 <code>p2</code>，则 <code>carry</code> 为：<code>(p1.Val + p2.Val) / 10</code>，<code>ans</code> 链表该位置上的结点 <code>p</code> 的值为 <code>(p1.Val + p2.Val) % 10</code>。</p><p>当较短的链表遍历完成之后，对于较长的链表，可以有以下两种处理方法：</p><ol><li>分情况讨论，对较长的链表继续与 <code>carry</code> 执行相加操作，比较容易想到但是代码比较复杂。</li><li>在较短的链表后面补 0（<code>p1</code> 或 <code>p2</code> 为 <code>nil</code> 时，将这个结点的值视为 <code>0</code>）并使用短链表没有遍历完成时的相加逻辑（代码比较简单）。</li></ol><p>两个链表都遍历完成之后，如果 <code>carry == 1</code>，则需要在 <code>ans</code> 的最后补上一个 <code>1</code>。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(max(m, n))，其中 m，n 为两个链表的长度。</p><p>空间复杂度：O(1)，除返回值外只使用了常数个数的空间。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><p>分类讨论：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    p1, p2 := l1, l2</span><br><span class="line">    ans := &amp;ListNode&#123;Val: <span class="number">0</span>, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">    p := ans</span><br><span class="line">    <span class="keyword">for</span> ; p1 != <span class="literal">nil</span> &amp;&amp; p2 != <span class="literal">nil</span>; p1, p2 = p1.Next, p2.Next &#123;</span><br><span class="line">        val := p1.Val + p2.Val + carry</span><br><span class="line">        carry = val / <span class="number">10</span></span><br><span class="line">        val %= <span class="number">10</span></span><br><span class="line">        node := &amp;ListNode&#123;Val: val, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">        p.Next = node</span><br><span class="line">        p = p.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; p1 != <span class="literal">nil</span>; p1 = p1.Next &#123;</span><br><span class="line">        val := p1.Val + carry</span><br><span class="line">        carry = val / <span class="number">10</span></span><br><span class="line">        val %= <span class="number">10</span></span><br><span class="line">        node := &amp;ListNode&#123;Val: val, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">        p.Next = node</span><br><span class="line">        p = p.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> ; p2 != <span class="literal">nil</span>; p2 = p2.Next &#123;</span><br><span class="line">        val := p2.Val + carry</span><br><span class="line">        carry = val / <span class="number">10</span></span><br><span class="line">        val %= <span class="number">10</span></span><br><span class="line">        node := &amp;ListNode&#123;Val: val, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">        p.Next = node</span><br><span class="line">        p = p.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry == <span class="number">1</span> &#123;</span><br><span class="line">        p.Next = &amp;ListNode&#123;Val: <span class="number">1</span>, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补 0:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">    carry := <span class="number">0</span></span><br><span class="line">    p1, p2 := l1, l2</span><br><span class="line">    ans := &amp;ListNode&#123;Val: <span class="number">0</span>, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">    p := ans</span><br><span class="line">    <span class="keyword">for</span> p1 != <span class="literal">nil</span> || p2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        val1, val2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            val1 = p1.Val</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            val2 = p2.Val</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        val := val1 + val2 + carry</span><br><span class="line">        carry = val / <span class="number">10</span></span><br><span class="line">        val %= <span class="number">10</span></span><br><span class="line">        node := &amp;ListNode&#123;Val: val, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">        p.Next = node</span><br><span class="line">        p = p.Next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">            p1 = p1.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> p2 != <span class="literal">nil</span> &#123;</span><br><span class="line">            p2 = p2.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> carry == <span class="number">1</span> &#123;</span><br><span class="line">        p.Next = &amp;ListNode&#123;Val: <span class="number">1</span>, Next: <span class="literal">nil</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/add-two-numbers/&quot;&gt;2. Add</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Linked List" scheme="http://site.noellemu.cloud/tags/Linked-List/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode HOT 100】1. Two Sum</title>
    <link href="http://site.noellemu.cloud/2e76cd4c5980/"/>
    <id>http://site.noellemu.cloud/2e76cd4c5980/</id>
    <published>2022-11-25T12:00:04.000Z</published>
    <updated>2022-11-25T14:51:00.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目地址"><a href="#题目地址" class="headerlink" title="题目地址"></a>题目地址</h2><p><a href="https://leetcode.cn/problems/two-sum/">1. Two Sum</a></p><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>这道题也是老熟人了，我感觉我至少做过五遍。</p><p>暴力解法（时间复杂度 <code>O(n^2)</code>）大家应该都知道，那就来讲讲非暴力解法吧。</p><p>我们可以用一个哈希表 <code>m</code> 保存 <code>nums</code> 中的元素与下标的对应关系，由于一个数字只能使用一次，因此我们遍历 <code>nums</code> 数组，每次都查找 <code>target</code> 与当前元素 <code>num</code> 的差值是否在哈希表中。如果在，则说明 <code>m[target-num] + num = target</code>，返回 <code>m[target-num]</code> 和 <code>num</code> 的下标 <code>i1</code>；如果不在，则将 <code>num</code> 及其下标添加到哈希表中（即 <code>m[num] = i1</code>）。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>时间复杂度：O(n)，需要遍历一次数组。</p><p>空间复杂度：O(n)，哈希表占用的内存空间与 <code>nums</code> 的长度相关。</p><h2 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">     m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> i1, ok := m[target-num]; !ok &#123;</span><br><span class="line">            m[num] = i</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> []<span class="type">int</span>&#123;i1, i&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目地址&quot;&gt;&lt;a href=&quot;#题目地址&quot; class=&quot;headerlink&quot; title=&quot;题目地址&quot;&gt;&lt;/a&gt;题目地址&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.cn/problems/two-sum/&quot;&gt;1. Two Sum&lt;/a&gt;</summary>
      
    
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/categories/Algorithm/"/>
    
    <category term="LeetCode" scheme="http://site.noellemu.cloud/categories/Algorithm/LeetCode/"/>
    
    
    <category term="Algorithm" scheme="http://site.noellemu.cloud/tags/Algorithm/"/>
    
    <category term="Hash Map" scheme="http://site.noellemu.cloud/tags/Hash-Map/"/>
    
  </entry>
  
  <entry>
    <title>记一次缓存引起的数据异常 Bug 的排查过程</title>
    <link href="http://site.noellemu.cloud/8f438e4dddfd/"/>
    <id>http://site.noellemu.cloud/8f438e4dddfd/</id>
    <published>2022-11-24T18:10:54.000Z</published>
    <updated>2022-11-24T19:19:00.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在我工作中开发的一个类似于 <code>Ansible</code> 和 <code>蓝鲸作业平台</code> 的作业平台中，由于 <code>MongoDB</code> 性能瓶颈导致 <code>NSQ</code> 消息队列积压严重，经讨论后决定将作业执行过程中的作业状态转换、作业日志存储等逻辑从直接读写 <code>MongoDB</code> 重构为基于 <code>sync.Map</code> 自行实现的进程内缓存——将作业数据以作业 ID 为 <code>key</code>，作业数据为 <code>value</code> 保存在 <code>sync.Map</code> 中（这个方案并不怎么好，后文会提到优化方案），并且启动了几个定时任务将 <code>sync.Map</code> 中的数据每隔 10 秒对执行中的作业执行历史数据进行落库操作。作业中所有步骤的执行历史信息在作业执行开始或跳过失败步骤时写入缓存和数据库，此后会进入一个类似 <code>Event Loop</code> 的无限 <code>for</code> 循环，每次循环都会根据作业执行目标的数量和状态判断作业的状态，若已成功结束（成功目标总数 <code>Succeed</code> &#x3D; 执行目标总数 <code>Total</code>）则会立即发送下一个步骤给执行目标。</p><p>这样一来，业务逻辑就发生了变化：</p><ul><li>优化前：作业执行消息到来 - 从 DB 中加载作业执行历史数据（主要是成功 &#x2F; 失败 &#x2F; 执行中三种状态的主机数量、重做次数等） - 根据执行历史数据和消息内容判断作业的状态 - 将状态和日志信息写入 DB。</li><li>优化后：作业执行消息到来 - 从缓存中加载作业执行历史数据（未命中缓存则查 DB）- 根据消息内容判断作业的状态 - 将状态和日志信息写入缓存 - 通过定时任务将作业执行历史信息落库（如果作业执行已经结束，则立即落库，降低资源消耗）。</li></ul><p>显而易见的是，这种机制是 <code>Cache Aside</code>（先查缓存，缓存未命中则查数据库，修改时先写 DB 再写缓存）和 <code>Read Through / Write Behind</code>（写操作直接写缓存，然后由定时任务同步到 DB） 的结合体。</p><p>但在某一天，出现了一个诡异的恶性 Bug：当作业的第一个步骤执行失败时，对这个步骤执行跳过操作，之后的所有步骤都会不经执行而直接被设为成功。若查看作业执行历史，会发现步骤实际上执行了，日志也成功返回到服务端。此外，该 Bug 是随机发生的，在触发条件未知的情况下无法 100% 复现。</p><p>由于这个 Bug 与步骤和作业的状态判断逻辑有关，可能会引发严重的问题，于是立即展开排查与修复工作。</p><h2 id="问题表现"><a href="#问题表现" class="headerlink" title="问题表现"></a>问题表现</h2><ul><li>该 Bug 是随机发生的，在不知晓原因的情况下无法 100% 复现。</li><li>必须有一个步骤（可以是第一步、第二步……第 n 步）失败并且对这个步骤执行跳过操作才有可能发生。</li><li>从作业执行开始到执行跳过操作的时间间隔非常短，最多 9 秒左右。</li><li>线上环境难以复现。</li></ul><h2 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h2><p>首先拉取 Bug 发生时的日志，会发现被错误地设为成功的步骤的执行目标总数 <code>Total</code> 在缓存中被错误地设置为 0，且对应步骤在作业执行开始第一次写入缓存时 <code>Total</code> 是正确的，而在执行跳过操作以后第一次被写入缓存时 <code>Total</code> 就被设为 0，怀疑是缓存 Bug，但对所有写缓存的操作进行查看和打日志之后，未发现有某处修改了 <code>Total</code> 操作或未设置 <code>Total</code> 值。</p><p>然后尝试复现，在测试了超过 100 次之后，发现可以复现问题的时间似乎与缓存落库定时任务的执行时间有关——例如缓存定时任务每 10 秒运行一次，第一次运行的时间为 yy:yy:y3，那么作业开始执行的时间必须在 xx:xx:x3 到 xx:xx:(x-1)3 之间，且必须在 xx:xx:(x-1)3 之前对某一执行失败的步骤执行跳过操作，否则就无法复现，怀疑是某处对 <code>Total</code> 值写了缓存但没有写 DB。</p><p>查看步骤跳过的逻辑，发现 <code>Total</code> 值只写了缓存，没有写数据库，问题实锤。</p><p>排查和修复过程大约花费一天半，几乎全程独立完成。</p><h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>在作业执行开始，创建所有步骤的执行历史信息并写入缓存和数据库时，执行主机数量 <code>Total</code> 字段只写入了缓存，没有写入数据库，导致所有步骤在数据库中储存的 <code>Total</code> 字段被初始化为 <code>int</code> 类型的零值（0）。若第一个步骤在 10 秒内执行完毕并点击跳过，由于跳过操作与执行失败这两个事件之间可能相隔很久，为了防止缓存失效，在每次跳过操作时都会直接查询数据库。此时若缓存落库定时任务还没有执行，查询操作就会将这个错误的 <code>Total: 0</code> 查询出来并覆盖缓存中正确的值。由于此时 <code>Succeed</code>、<code>Failed</code>、<code>Total</code> 三个字段都等于 0，所以在 <code>for</code> 循环中虽然会将作业执行信息发送给执行目标，但执行状态在状态判断逻辑中会被直接判断为成功，进而导致了问题的产生。</p><p>当从作业开始执行的时间（设为 <code>tstart</code>）到对失败步骤执行跳过的时间（设为 <code>tend</code>）小于 <code>tstart</code> 之后缓存落库定时任务下一次执行的时间与 <code>tstart</code> 的间隔（设为 <code>ttask</code>），即 <code>tend - tstart &lt; ttask</code> 时，缓存落库定时任务执行过一次之后，由于缓存中正确的 <code>Total</code> 值已经被写入数据库，查询操作读取到的就是正确的值，问题也就不会发生了。</p><p>而由于线上环境执行的作业由于执行目标比较多、脚本逻辑比较复杂等原因，单个步骤的运行时间一般都大于 10 秒，所以这个步骤在线上环境很难复现。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>在作业执行开始时，将主机数量同时写入数据库和缓存，而不是只写缓存不写数据库。</li><li>对于失败步骤的跳过操作，应直接查缓存，未命中缓存再查询数据库，而不是直接查询数据库。</li><li>提高缓存落库定时任务的执行频率，降低问题发生的概率（当然这并不能从根本上解决问题）。</li></ol><h2 id="缓存功能的优化方案"><a href="#缓存功能的优化方案" class="headerlink" title="缓存功能的优化方案"></a>缓存功能的优化方案</h2><ol><li>不使用 <code>sync.Map</code> 而是使用功能更加完备的进程内缓存框架（如 <code>gcache</code> 等）。</li><li>可以只缓存与作业状态判断和日志更新相关的小部分数据（如作业 ID、作业的当前状态、重做次数）等，日志则写入消息队列并异步写入数据库（削峰填谷），降低内存占用。</li><li>若考虑多点部署的问题，由于有进程内缓存意味着作业服务是有状态的，所以需要采用一致性哈希等机制将不同的作业 ID 映射到不同的作业服务实例上去，或者采用单独的缓存数据库实现跨进程的缓存（如 <code>Redis</code> 等）。</li><li>日志不应该直接写到作业执行历史的某个数组类型的字段（如 <code>logs</code>）中，而应该写到专门的日志数据库（如 <code>ElasticSearch</code>）中，这不仅仅是因为这些数据库对海量数据的查询操作具有天然的优势，更可以将查询执行历史元数据和查询日志数据的操作分开，提升系统的性能（这一点考虑之后结合 <code>Metropolitan</code> 写篇文章讲讲）。</li><li>现有的缓存机制在进程 <code>panic</code> 异常退出时会导致未落库的数据（执行中的作业执行历史数据）丢失，需要特别注意在 <code>recover</code> 兜底中将数据落库（怀疑之后数次日志丢失 &#x2F; 作业状态判断不正确的偶现 bug 可能由此引起）。</li></ol><h2 id="附：缓存读写的业界推荐原则"><a href="#附：缓存读写的业界推荐原则" class="headerlink" title="附：缓存读写的业界推荐原则"></a>附：缓存读写的业界推荐原则</h2><ul><li>增：先写 DB，再写缓存。</li><li>删：先删 DB，再删缓存（并发的情况下可能会读到脏数据，但概率比较小）。</li><li>改：先写 DB，再写缓存（同样可能有脏数据问题）。</li><li>查：先查缓存，未查到则查 DB，并把查到的数据同步到缓存。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在我工作中开发的一个类似于 &lt;code&gt;Ansible&lt;/code&gt; 和 &lt;code&gt;蓝鲸作业平台&lt;/code&gt; 的作业平台中，由于 &lt;co</summary>
      
    
    
    
    <category term="Golang" scheme="http://site.noellemu.cloud/categories/Golang/"/>
    
    <category term="Trouble Shooting" scheme="http://site.noellemu.cloud/categories/Golang/Trouble-Shooting/"/>
    
    
    <category term="Golang" scheme="http://site.noellemu.cloud/tags/Golang/"/>
    
    <category term="Cache" scheme="http://site.noellemu.cloud/tags/Cache/"/>
    
    <category term="Trouble Shooting" scheme="http://site.noellemu.cloud/tags/Trouble-Shooting/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言中的 defer</title>
    <link href="http://site.noellemu.cloud/24a2480bc47a/"/>
    <id>http://site.noellemu.cloud/24a2480bc47a/</id>
    <published>2022-11-24T16:30:21.000Z</published>
    <updated>2022-11-24T17:59:47.720Z</updated>
    
    <content type="html"><![CDATA[<h2 id="defer-的作用"><a href="#defer-的作用" class="headerlink" title="defer 的作用"></a>defer 的作用</h2><p><code>defer</code> 是 Go 语言提供的一种延迟执行的机制，可以让函数或者语句在当前函数返回（<code>panic</code> 或者 <code>return</code>）之后执行，且在 <code>panic</code> 之后仍然有效，也就是先 <code>return</code> &#x2F; <code>panic</code>，后 <code>defer</code>。</p><p><code>defer</code> 常见的用法是关闭文件、关闭连接、释放资源等，但也可以用来执行一些在不知道是否会 <code>panic</code> 的情况下必须执行的操作。比如在项目中，有一个向服务端汇报执行日志的函数 <code>SendMsg()</code>，并且在汇报日志之前需要先做一些处理（例如将日志写到文件中等），在发生丢日志的操作之后发现这些处理逻辑可能产生 <code>panic</code>，这时候就可以使用 <code>defer</code> 来完成汇报日志的操作，确保无论处理逻辑是否 <code>panic</code>，日志都会被正常地上报。</p><p>此外，使用 <code>defer</code> 配合 <code>recover</code> 进行 <code>panic</code> 兜底并完成一些“收尾操作”（如关闭连接、关闭文件等）也是很常见的操作（实际上 <code>recover</code> 在正常情况下只能配合 <code>defer</code> 和匿名函数一起使用，直接执行只会返回 <code>nil</code>）。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h2 id="defer-的执行顺序"><a href="#defer-的执行顺序" class="headerlink" title="defer 的执行顺序"></a>defer 的执行顺序</h2><p><code>defer</code> 遵循栈“先进后出”的特点，也就是先定义的 <code>defer</code> 后执行。</p><h2 id="defer-的参数"><a href="#defer-的参数" class="headerlink" title="defer 的参数"></a>defer 的参数</h2><p><code>defer</code> 的函数参数会在 <code>defer</code> 定义时被保存下来，如果是值类型的参数，则 <code>defer</code> 实际执行时与 <code>defer</code> 定义时一致；如果是引用类型的参数，则不一定一致（因为指针指向的内容可能会被修改）。</p><p>也就是说，如果 <code>defer</code> 后跟的语句不是闭包（匿名函数），那么在 <code>defer</code> 在定义时，参数就已经确定了。如果是闭包，则会在实际执行时根据闭包的上下文来确定。</p><p>因此，如果 <code>defer</code> 的参数中含有函数调用，那么在 <code>defer</code> 定义处需要先执行这个函数以获取 <code>defer</code> 函数的参数，之后 <code>defer</code> 会正常执行。</p><p>有时候我们可以利用这样的特性确保 <code>defer</code> 可以做正确的事情，例如一个进程要循环发起多个网络请求并获取响应，我们就可以利用 <code>defer</code> 的特点确保所有的响应体都被正确关闭，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">    resp, err := http.Get(url)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里由于 <code>resp.Body.Close()</code> 不是闭包，所以在 <code>defer</code> 语句处 <code>resp.Body</code> 的值已经确定并且被缓存下来，函数返回后实际执行 <code>defer</code> 时就不会出现错误了。</p><h2 id="defer-遇上-panic"><a href="#defer-遇上-panic" class="headerlink" title="defer 遇上 panic"></a>defer 遇上 panic</h2><p><code>defer</code> 遇上 <code>panic</code> 可以分以下几种情况讨论：</p><ol><li>如果 <code>defer</code> 执行的函数是 <code>nil</code>，则会引发 <code>panic</code>。</li><li>当函数发生 <code>panic</code> 时，会开始遍历 <code>defer</code> 链表，按照先进后出的顺序执行 <code>defer</code>，此时每个 <code>defer</code> 都可以捕获到 <code>panic</code>。</li><li>遇到前文提到的 <code>recover</code> “兜底”代码时，<code>panic</code> 会被捕获，之后所有的 <code>defer</code> 都无法捕获 <code>panic</code>。</li><li>如果 <code>defer</code> 栈中有多个 <code>panic</code>，则后面触发的 <code>panic</code> 会覆盖掉前面触发的 <code>panic</code>，最终仅有最后一个 <code>panic</code> 被 <code>recover</code> 捕获。</li><li>如果遍历完 <code>defer</code> 链表都没有遇上 <code>recover</code>，则向 <code>stderr</code> 抛出 <code>panic</code> 信息，并结束进程。</li></ol><h2 id="使用-defer-修改函数的返回值"><a href="#使用-defer-修改函数的返回值" class="headerlink" title="使用 defer 修改函数的返回值"></a>使用 defer 修改函数的返回值</h2><p>由于 Go 语言中的函数返回值是可以命名的，这些命名的返回值会在函数开始时被初始化为对应类型的零值，作用域为整个函数（包括 <code>defer</code>），因此可以使用 <code>defer</code> 修改这些返回值。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(doSomething())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> (retValue <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        retValue++</span><br><span class="line">    &#125;()</span><br><span class="line">    retValue = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;defer-的作用&quot;&gt;&lt;a href=&quot;#defer-的作用&quot; class=&quot;headerlink&quot; title=&quot;defer 的作用&quot;&gt;&lt;/a&gt;defer 的作用&lt;/h2&gt;&lt;p&gt;&lt;code&gt;defer&lt;/code&gt; 是 Go 语言提供的一种延迟执行的机制，可以让</summary>
      
    
    
    
    <category term="Golang" scheme="http://site.noellemu.cloud/categories/Golang/"/>
    
    <category term="Interview" scheme="http://site.noellemu.cloud/categories/Golang/Interview/"/>
    
    
    <category term="Golang" scheme="http://site.noellemu.cloud/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>死锁产生的条件及预防方法</title>
    <link href="http://site.noellemu.cloud/03ea9547f4e6/"/>
    <id>http://site.noellemu.cloud/03ea9547f4e6/</id>
    <published>2022-11-24T16:20:12.000Z</published>
    <updated>2022-11-24T16:28:41.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><p>死锁的产生一共有四个条件：</p><ol><li><strong>互斥条件</strong>：一个资源同一段时间内只能为一个进程所用。</li><li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已经持有的资源保持不放。</li><li><strong>不剥夺条件</strong>：进程获得的资源在使用完毕前不能剥夺，必须由进程主动释放。</li><li><strong>环路等待条件</strong>：在发生死锁的时候必定存在一个进程-资源的环形链。</li></ol><h2 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h2><p>破坏死锁产生的四个条件中的任意一个即可预防死锁的产生。</p><ol><li><strong>破坏互斥条件</strong>：把互斥资源变为共享资源，例如共享打印机技术等。</li><li><strong>破坏请求和保持资源</strong>：可以一次性分配所有资源，也可以当某个进程得不到某项资源时，也不给它分配其他资源。</li><li><strong>破坏不剥夺条件</strong>：当某个进程获得了一部分资源但得不到其他资源时，则释放这个进程已经占有的资源。</li><li><strong>破坏环路等待条件</strong>：系统给每类资源赋予一个编号，进程在请求资源时需要按照编号从大到小的方式请求，释放时则相反。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;死锁产生的条件&quot;&gt;&lt;a href=&quot;#死锁产生的条件&quot; class=&quot;headerlink&quot; title=&quot;死锁产生的条件&quot;&gt;&lt;/a&gt;死锁产生的条件&lt;/h2&gt;&lt;p&gt;死锁的产生一共有四个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：一</summary>
      
    
    
    
    <category term="Operating System" scheme="http://site.noellemu.cloud/categories/Operating-System/"/>
    
    <category term="Interview" scheme="http://site.noellemu.cloud/categories/Operating-System/Interview/"/>
    
    
    <category term="Operating System" scheme="http://site.noellemu.cloud/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Go 语言中的 make 函数</title>
    <link href="http://site.noellemu.cloud/bb889d5764e8/"/>
    <id>http://site.noellemu.cloud/bb889d5764e8/</id>
    <published>2022-11-24T16:13:56.000Z</published>
    <updated>2022-11-24T16:28:46.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>某一天在阅读公众号时，遇到了这样一道问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码输出什么？</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>, <span class="number">3</span>)</span><br><span class="line">    m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d %d&quot;</span>, <span class="built_in">len</span>(m1), <span class="built_in">len</span>(m2))</span><br><span class="line">    m1[<span class="string">&quot;a&quot;</span>] = <span class="literal">true</span></span><br><span class="line">    m2[<span class="string">&quot;a&quot;</span>] = <span class="literal">true</span></span><br><span class="line">    m1[<span class="string">&quot;b&quot;</span>] = <span class="literal">true</span></span><br><span class="line">    m2[<span class="string">&quot;b&quot;</span>] = <span class="literal">true</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d %d&quot;</span>, <span class="built_in">len</span>(m1), <span class="built_in">len</span>(m2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是 <code>0 0</code> 和 <code>2 2</code>。</p><h2 id="make-函数对不同数据类型的作用"><a href="#make-函数对不同数据类型的作用" class="headerlink" title="make() 函数对不同数据类型的作用"></a>make() 函数对不同数据类型的作用</h2><p>这道问题涉及到了关于 <code>make</code> 函数的一个知识点：<code>make</code> 函数用于初始化某些数据类型时，其参数具有哪些意义？<br>首先，<code>make</code> 函数可以用于初始化三种数据类型：<code>slice</code>、<code>map</code>、<code>channel</code>。我们比较熟悉的用法一般是用于在初始化 <code>slice</code> 的时候指定长度（例如 <code>make([]int, 10)</code> 可以初始化一个初始长度为 10 的 <code>int</code> 类型切片）和在初始化 <code>channel</code> 的时候指定该 <code>channel</code> 有无缓冲（例如 <code>make(chan int, 1)</code> 可以初始化一个缓冲区大小为 1 的 <code>int</code> 类型的 <code>channel</code>）。<br>但是一般情况下，当 <code>make</code> 用于初始化 <code>map</code> 时，一般都只有类型这一个参数，例如 <code>make(map[int]bool)</code>。那么第二个参数对于 <code>map</code> 来说意味着什么呢？<br>下面这张表格会告诉我们答案：</p><table><thead><tr><th>调用方式</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td>make(T, len)</td><td>slice</td><td>初始化一个长度为 len，容量为 cap 的 slice</td></tr><tr><td>make(T, len, cap)</td><td>slice</td><td>初始化一个长度为 len 的 slice</td></tr><tr><td>make(T)</td><td>map</td><td>初始化一个 map</td></tr><tr><td>make(T, cap)</td><td>map</td><td>初始化一个容量<strong>大约</strong>为 cap 的 map</td></tr><tr><td>make(T)</td><td>channel</td><td>初始化一个无缓冲的 channel</td></tr><tr><td>make(T, cap)</td><td>channel</td><td>初始化一个缓冲区大小为 cap 的 channel</td></tr></tbody></table><p>因此，上面那道题目的答案就显而易见了：<code>len</code> 返回的是 <code>map</code> 中键值对的个数，而 <code>make(map[int]bool, 3)</code> 初始化了一个长度为 0、容量为 3 的 <code>map</code>，其初始长度自然就是 0 了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;某一天在阅读公众号时，遇到了这样一道问题：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    <category term="Golang" scheme="http://site.noellemu.cloud/categories/Golang/"/>
    
    <category term="Interview" scheme="http://site.noellemu.cloud/categories/Golang/Interview/"/>
    
    
    <category term="Golang" scheme="http://site.noellemu.cloud/tags/Golang/"/>
    
  </entry>
  
</feed>
